// Serial  Number  / s  :    22 and 17
//
//Author : Colby Isaacks and Justice Gutierrez
//
// Programming Assignment Number  4
//
// Fall   2019   -   CS 3358    -    01
//
// Due Date  :  October 21st, 2019
//
// Instructor:    Husain Gholoom.
//
// In this assignment, we creates and operate on a stack and a queues using
// a linked list implementation



#include <iostream>

using namespace std;

class Stack{                                //Stack class
private:
    struct Node{
        int data;
        Node *link;
    };
public:
    Node* top = NULL;       //initializes a new top node

    void push(int value){       //push function takes int value and adds it to
                                //the top of the stack
        Node *newNode = new Node();
        newNode->data = value;
        newNode->link = top;
        top = newNode;
    }

    void pop(){                 //pop function removes value from top of stack
        if(top == NULL){
            cout << "Stack Underflow" << endl;
        }
        else{
            top = top->link;
        }
    }

    void display(){             //prints out the contents of the stack
        struct Node *ptr;
        if(top == NULL){
            cout << "Stack is empty" << endl;
        }
        else{
            ptr = top;
            while(ptr != NULL){
                cout << ptr->data << " ";
                ptr = ptr->link;
            }
        }
    }

    void deleteAll(){           //deletes all elements of the stack
        top = NULL;
        cout << "The stack is now empty." << endl << endl;
    }
};

class Queue{                            //Queue class
private:
    struct Node{
        int data;
        Node *link;
    };
public:
    Node *backNode = NULL;          //declare nodes to represent the back and
    Node *frontNode = NULL;         //the front of the queue

    void enqueue(int value){      //adds an int value to the queue
        Node *temp = new Node;
        temp->data = value;
        temp->link = NULL;

        if(frontNode == NULL){
            frontNode = backNode = temp;
        }
        else{
            backNode->link = temp;
            backNode = temp;
        }
    }

    void dequeue(){
        if(frontNode == NULL){     //removes value form the front of the queue
            cout << "The queue is empty" << endl;
        }
        else{
            frontNode = frontNode->link;
        }
    }

    void insertAtLocation(int value, int location){  //inserts specific value at
        Node *temp = new Node();                     // a specific index
        Node *current;  //a node to keep track of the position in the queue
        Node *last;     //a node pointing to the previous location
        temp->data = value;
        temp->link = NULL;
        int position = 0;

        if(frontNode == NULL){
            cout << "There are no elements in this queue." << endl << endl;
            return;
        }
        else if(frontNode != NULL && location == 0){
            temp->link = frontNode;
            frontNode = temp;
            return;
        }

        current = frontNode;
        last = NULL;

        while(position < location){
            last = current;
            current = current->link;

            if(current == NULL){
                break;
            }
            position++;
        }
        temp->link = current;
        last->link = temp;
    }

    void deleteAtLocation(int location){  //deletes the element at a specific
        Node *current;                    //location
        Node *last;
        int position = 0;

        current = frontNode;
        last = NULL;

        if(frontNode == NULL){
            cout << "There are no elements in this queue." << endl << endl;
        }
        else if(frontNode != NULL && location == 0){
            frontNode = frontNode->link;
            return;
        }
        else{
            current = current->link;
            last = frontNode;
            last->link = current;
            position++;
            while(current != NULL){
                if(position == location){
                    current = current->link;
                    last->link = current;
                    return;
                }
                else if(position != location){
                    current = current->link;
                    last = last->link;
                    position++;
                }
            }
        }
    }

    void display(){                     //prints out the contents of the queue
        Node *ptr;
        if(frontNode == NULL){
            cout << "The queue is empty" << endl;
        }
        else{
            ptr = frontNode;
            while(ptr != NULL){
                cout << ptr->data << " ";
                ptr = ptr->link;
            }
        }
    }

    int findMax(){              //finds and returns the max value of the queue
        Node *ptr;
        int maxValue = frontNode->data;

        ptr = frontNode;
        while(ptr != NULL){
            if(ptr->data > maxValue)
                maxValue = ptr->data;
                ptr = ptr->link;
        }
        return maxValue;
    }

    int findMin(){          //finds and returns the minimum value of the queue
        Node *ptr;
        int minValue = frontNode->data;

        ptr = frontNode;
        while(ptr != NULL){
            if(ptr->data < minValue)
                minValue = ptr->data;
                ptr = ptr->link;
        }
        return minValue;
    }

    float findAverage(){      //finds and returns the average value of the queue
        Node *ptr;
        float numNodes = 0; //keeps track of the number of nodes in queue
        float sum = 0;      //keeps track of the sum of node values
        float average;      //the average of all node values

        ptr = frontNode;
        while(ptr != NULL){
            sum += ptr->data;
            numNodes++;
            ptr = ptr->link;
        }
        average = sum / numNodes;
        return average;
    }

    void deleteAll(){   //deletes all elements of the queue
        frontNode = backNode = NULL;
        cout << "The queue is now empty." << endl << endl;
    }
};


int main()
{
    Stack thisStack;   //initializes our stack
    Queue thisQueue;   //initializes our queue
    char choice;       //user choice
    bool valid = false; //tells whether user choice is valid, initially false
    do{
        cout << "A. Insert new element in the Stack (LIFO)." << endl;
        cout << "B. Remove an element from the stack (LIFO)." << endl;
        cout << "C. Insert new element in the queue (FIFO)." << endl;
        cout << "D. Insert an element at specific location in the queue."
             << endl;
        cout << "E. Remove an element from the queue (FIFO)." << endl;
        cout << "F. Remove a specific element from the queue." << endl;
        cout << "G. Find Min element in the queue, Max element in the" << endl;
        cout << "   queue, and the Average of the queue." << endl;
        cout << "H. Delete the entire stack." << endl;
        cout << "I. Delete the entire queue." << endl;
        cout << "X. Exit the program." << endl << endl;

        cin >> choice;

        if(choice == 'A'){
            valid = true;
            int value;

            cout << "Enter the value to be added to the stack: ";
            cin >> value;
            cout << endl;

            thisStack.push(value);
            thisStack.display();
            cout << endl << endl;
        }

        else if(choice == 'B'){
            valid = true;

            thisStack.pop();
            thisStack.display();
            cout << endl << endl;
        }

        if(choice == 'C'){
            valid = true;
            int value;

            cout << "Enter the value to be added to the queue: ";
            cin >> value;
            cout << endl;

            thisQueue.enqueue(value);
            thisQueue.display();
            cout << endl << endl;
        }

        else if(choice == 'D'){
            valid = true;
            int value;
            int position;

            cout << "Enter the value to be entered : ";
            cin >> value;
            cout << "\nEnter the position of the new value (0 is the first";
            cout <<" position): ";
            cin >> position;

            thisQueue.insertAtLocation(value, position);
            thisQueue.display();
            cout << endl << endl;
        }

        else if(choice == 'E'){
            valid = true;

            thisQueue.dequeue();
            thisQueue.display();
            cout << endl << endl;
        }

        else if(choice == 'F'){
            valid = true;
            int position;

            cout << "\nEnter the position to be deleted (0 is the first";
            cout <<" position): ";
            cin >> position;

            thisQueue.deleteAtLocation(position);
            thisQueue.display();
            cout << endl << endl;
        }

        else if(choice == 'G'){
            valid == true;
            int maximum = thisQueue.findMax();
            int minimum = thisQueue.findMin();
            float average = thisQueue.findAverage();

            cout << "Max: " << maximum << endl;
            cout << "Min: " << minimum << endl;
            cout << "Average: " << average << endl << endl;
        }

        else if(choice == 'H'){
            thisStack.deleteAll();
        }

        else if(choice == 'I'){
            thisQueue.deleteAll();
        }

        else if(choice == 'X'){
            cout << "This LL/ Stack & Queue Program is Implemented By :-Colby ";
            cout << "Isaacks and Justice Gutierrez - October 21st, 2019";
            cout << endl;
            exit(0);
        }

        else if(valid == false){
            cout << "Error: Invalid input. Input must be uppercase character"
                 << endl << endl;
        }
    }while(valid == false || choice != 'X');
}